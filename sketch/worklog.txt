2012.01.21.00.04.49

Ок. Кажется, глубокие деревья процессов могут сработать, если собирать pid-ы
через каналы.

Не понятно, как промаршалить SIGCHLD.

2012.01.28.00.01.07

Ну, хорошо. Такая мысль. Тот указатель на конфигурацию, который возвращает
preroutine может быть и не на динамическую структуру данных. Наверное, не надо
делать free при управлении запусками.

Это сделает попроще логику работы с нитями. Плюс будет некая жертва для
структуры адресного пространства у процессов. Оно всё равно будет не сильно
хуже, чем у нитей.

Ладно. Пофиксим немного.

2012.01.28.11.38.09

Это плохой fix. Он работает с процессами. А вот с нитями надо дожидаться
завершения дочерних нитей, чтобы потом безопасно удалить parentarg. Тут
возникает вопрос: каким образом?

Либо усложнять нужно интерфейс.

В принципе, сложный интерфейс позволит подчищать кое-что и в процессах.
Придётся делать интерфейс. Эх... Сделаем.

2012.01.31.19.07.11

Так. Мы не можем сделать runconfig определённого размера. Но для упрощения,
потока контроля, мы можем засунуть поле runconfig в структуру с
функциями для запуска в дереве.

В этой же структуре полезным будет параметр extrasetup, в который
запишется дополнительный аргумент для функций дерева.

2012.02.07.14.27.31

Идея такая. Для exchange-теста было бы неплохо избегать ненужных copy-on-write
операций. Возомжно, имеет смысл после выгрузки данных вектора в shm-файл
просто освобождать память, занимаемую вектором через munmap.

А после загрузки из shm-файла, его можно обнулять при помощи truncate.

Да будет так в этой версии (0.3), которая, на самом деле, 1.2
