Добро пожаловать в 0xfb thread proc benchmark -- набор тестов для сравнения
эффективности разбиений некоторого набора вычислений на нити и на процессы.

1. Сборка. Для сборки исполняемых файлов с программами тестов необходимо
сделать следующее.

	1.1 Если Вы ещё не сделали это, то получить исходные тексты тестов.
		Например, так:

		
		$ git clone git://github.com/coda/thread-proc.git thread-proc

	1.2 Для сборки тестов нужны некоторые дополнительные модули, которые
		следует получить при помощи скрипта foreign-up, находящегося
		в корне дерева исходных текстов тестов:

		$ cd thread-proc
		$ sh foreign-up git://github.com/coda

		Аргумент для foreign-up -- это путь для поиска модулей и он
		должен совпадать с указанным, если Вы не разместили
		необходимые модули по другому адресу. Для работы foreign-up
		требуется пакет Git

	1.3 Процесс сборки запускает скрипт build. По-умолчанию он будет
		собирать исполняемые файлы тестов при помощи набора утилит GCC
		с оптимизацией времени связывания (LTO -- Link Time
		Optimization) в рабочей директории bld, находящуюся в корне
		дерева исходных текстов. Эту директорию необходимо создать
		перед запуском build:

		$ mkdir bld
		$ sh build

		Поведение build можно изменить при помощи ключей:

			-d	собирать отладочные версии исполняемых файлов
			-b dir	использовать dir в качестве рабочей директории
			-t tcn	использовать набор компиляторов tcn.
				Поддерживаемые наборы: clang, gcc, gcc-nolto.
				Последний необходимо использовать c относительно
				старыми версиями GCC.
			-j n	количество работ для make, аналог аналогичной
				опции.

2. Тестирование.

В процессе сборки build разместит все необходимые для тестирования исполняемые
файлы в поддиректорию bin используемой для процесса сборки директории.
Запускающий все тесты скрипт runall находится там же. Тестирование можно
запустить командой:

	$ bld/bin/runall

Скрипт runall реагирует на несколько ключей в командной строке:

	-u n	количество задач (нитей или процессов) до которого следует
		доводить тестирование. Тесты начинаются с 1 задачи, а затем
		их количество доводится до не более чем n в геометрической
		прогрессии с показателем 2: 1, 2, 4, 8, ... По-умолчанию,
		512.

	-m sz	размер матрицы для тестов с умножением матриц. Матрицы получат
		размер sz * 512. По-умолчанию, 2 (матрицы размером 1024x1024).

	-a it	количество итераций для теста с выделением памяти. Количество
		итераций будет равно it * 1024 * 1024. По-умолчанию, 4
		(число итераций 4194304).

	-e it	количество итераций для теста с обменами. Количество итераций
		будет равно it * 1024. По-умолчанию, 64 (число итераций 65536).

3. Большие страницы.

Для того, чтобы программы с умножением матриц могли использовать большие
страницы, а не завершаться с ошибкой (FAIL в колонках HP.P и HP.P-FS в списке
результатов) необходимо включить поддержку больших страниц.

Для систем на основе ядра Linux (ядро должно быть достаточно новым) это
делается следующим образом:

	# echo gid > /proc/sys/vm/hugetlb_shm_group

Здесь gid -- номер группы пользователей, которым разрешено использовать большие
страницы. Естественно, это должен быть номер одной из групп, в которые входит
пользователь, от чьего имени запускаются тесты.

	# echo N > /proc/sys/vm/nr_hugepages

Здесь N -- количество больших страниц, которые система должна зарезервировать
для работы. Большая страница для систем на базе процессоров x86-64 имеет длину
2MiB, и N должно быть достаточным для размещения 3-ёх матриц, запрашиваемого
размера.

Выполнения этих команд достаточно, чтобы заработал тест HP.P для умножения
матрицы. Чтобы заработал тест HP.P-FS (процессы с общей памятью на основе
файловой системы с большими страницами) необходимо смонтировать соответствующую
файловую систему в точку монтирования /tmp/hugetlb (этот путь прописан в
исходных текстах программы):

	mount -t hugetlbfs -o size=SZ,uid=UID none /tmp/hugetlb

Здесь SZ -- объём памяти, который будет отведён под большие страницы данной
файловой системы. UID -- номер пользователя, который получит возможность
работать с этой ФС.
